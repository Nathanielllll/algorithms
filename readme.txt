<h1>面试题</h1>
<h2>操作系统</h2>

- Linux: 为什么要用IO多路复用？

  原因:
  由于进程的执行过程是线性的(也就是顺序执行),当我们调用低速系统I/O(read,write,accept等等),进程可能阻塞,此时进程就阻塞在这个调用上,不能执行其他操作.阻塞很正常. 接下来考虑这么一个问题:一个服务器进程和一个客户端进程通信,服务器端read(sockfd1,bud,bufsize),此时客户端进程没有发送数据,那么read(阻塞调用)将阻塞直到客户端调用write(sockfd,but,size)发来数据. 在一个客户和服务器通信时这没什么问题,当多个客户与服务器通信时,若服务器阻塞于其中一个客户sockfd1,当另一个客户的数据到达套接字sockfd2时,服务器不能处理,仍然阻塞在read(sockfd1,...)上;此时问题就出现了,不能及时处理另一个客户的服务,咋么办?  I/O多路复用来解决!
  I/O多路复用:
  继续上面的问题,有多个客户连接,sockfd1,sockfd2,sockfd3..sockfdn同时监听这n个客户,当其中有一个发来消息时就从select的阻塞中返回,然后就调用read读取收到消息的sockfd,然后又循环回select阻塞;这样就不会因为阻塞在其中一个上而不能处理另一个客户的消息

- select poll epoll

  **select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 

- 如何设计一个server，在收到多个客户端请求的时候，返回打印"Hello World"

  使用netty的设计模式

- 客户端崩了，如何在服务端强制断开tcp连接？

  1. 用netstat -anp命令来查找连接对于的pid，然后把相应的进程杀掉？

  2. 利用dsniff的tcpkill杀TCP连接

- 客户端意外挂掉，Server如何处理？/ server挂了，client怎么办？

  在进程正常退出时会自动调用close函数来关闭它所打开的文件描述符，这相当于服务器端来主动关闭连接——会发送一个FIN分节给客户端TCP；客户端要做的就是配合对端关闭连接，TCP会自动响应一个ACK，然后再由客户端应用程序调用close函数，也就是我们上面所描述的关闭连接的4次挥手过程。

- ***常见的 进程通信方式（不说进程同步）***

  1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  3. 消息队列MessageQueue：
     - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
     - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
     - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
  4. 共享存储SharedMemory：共享内存就是映射到各个进程的内存中，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
  5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
  6. 套接字Socket：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

- **操作系统 线程同步**![img](https://img-blog.csdn.net/20171121130628916)

- 操作系统**进程空间**是怎样的？线程能**共享**哪些？

  **程序段(Text):**程序代码在内存中的映射，存放函数体的二进制代码。

  **初始化过的数据(Data):**在程序运行初已经对变量进行初始化的数据。

  **未初始化过的数据(BSS):**在程序运行初未对变量进行初始化的数据。

  **堆 (Heap):**存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表。

  

  **栈 (Stack):**存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈。

  

  1. 共享的：程序段、公共的数据、堆；进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

  2. 不共享的：

     - 线程ID
          每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

     - 寄存器
          由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

     - 线程的栈
          栈是保证线程独立运行所必须的。线程函数可以调用函数，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。

     - 错误返回码
          由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。 所以，不同的线程应该拥有自己的错误返回码变量。

     - 线程的信号屏蔽码
          由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。

     - 线程的优先级

<h2>Java的线程间通信</h2>

1. syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()
2. volatile
3. ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()
4. 管道流主要用来实现两个线程之间的二进制数据的传播，以PipedInputStream类和PipedOutputStream类为例

<h2>多态的实现原理</h2>

- 类信息包含方法表，**表中的每一项都是指向相应方法的指针。**

- **编译时多态 和 运行时多态**

  1. **编译时多态（又称静态多态）**：重载（overload）就是编译时多态的一个例子，多态在编译时就已经确定，运行时调用的是确定的方法

  2. **运行时多态（又称动态多态）：** **我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**有两种实现方式：

     - **子类继承父类（extends）**

     - **类实现接口（implements）**

     

     多态的实例方法调用实际上有两种指令：

     **invokevirtual指令用于调用声明为类的方法：**方法的排列特性（Object——父类——子类），使得**方法表的偏移量总是固定的**。

     **invokeinterface指令用于调用声明为接口的方法。**当使用invokeinterface指令调用方法时，就不能采用固定偏移量的办法，只能老老实实挨个找了。**在性能上，调用接口引用的方法通常总是比调用类的引用的方法要慢。**

<h2>直接引用和符号引用</h2>

- 加载->验证->准备->**解析**->初始化
- 符号引用即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。而直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。**那为什么要用符号引用呢？**这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量他们的引用地址在哪里，所以只能用符号引用来表示。而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

<h2>count(*), count(1), count(col)的区别</h2>

- `MySQL`官方文档：对于`COUNT(1)`和`COUNT(*)`，`MySQL`的优化是完全一样的，根本不存在谁比谁快！

- 相比`COUNT(*)`，`COUNT(列名)`多了一个步骤就是判断所查询的字段是否为`NULL`，所以他的性能要比`COUNT(*)`慢。

- `COUNT(*)优化: MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询; InnoDB`会在扫表的时候选择最小的索引来降低成本。

- `COUNT`函数用于统计表行数，按照效率比较的话：

  ```sql
  count(*)=count(常量)>count(列名)
  ```

<h2>java中接口和抽象类的区别</h2>

- 相同点：
  （1）都不能被实例化
  （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

- 不同点：
  （1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
  （2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  （3）**接口**成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的（java 1.8之后接口好像就可以定义非抽象的方法了）。**抽象类**中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号（抽象类当中也可以有非抽象方法：*虚方法（子类可以重写也可以不重写，方法实现需要加上 override 关键字）*，*普通方法*）。
  （4）接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。

<h2>停止一个线程</h2>

- 停止一个线程可以用Thread.stop()方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是十分暴力的*（不安全*的）**（会数据造成不一致性的结果）**，而且是已被废弃的方法。调用stop()方法时会抛出java.lang.ThreadDeath异常

- 使用interrupt()方法、interrupted()/isInterrupted()方法、抛出异常

  1. interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。

  2. 判断线程是否停止状态

     Thread.java类中提供了两种方法：

     1. this.interrupted(): 测试当前线程是否已经中断；**测试当前线程是否已经中断。线程的中断状态由该方法清除。** 换句话说，如果连续两次调用该方法，则第二次调用返回false。
     2. this.isInterrupted(): 测试线程是否已经中断；isInterrupted()并为清除状态，所以打印了两个true。

  3. 句来判断一下线程是否是停止状态，如果是停止状态，则抛出异常即可

     ```java
     public class MyThread extends Thread {
         public void run(){
             super.run();
             try {
                 for(int i=0; i<500000; i++){
                     if(this.interrupted()) {
                         System.out.println("线程已经终止， for循环不再执行");
                             throw new InterruptedException();
                     }
                     System.out.println("i="+(i+1));
                 }
     
                 System.out.println("这是for循环外面的语句，也会被执行");
             } catch (InterruptedException e) {
                 System.out.println("进入MyThread.java类中的catch了。。。");
                 e.printStackTrace();
             }
         }
     }
     ```

<h2>创建线程的3种方法和优缺点</h2>

- 继承Thread类创建线程类
  1. 重写run方法。该run（）方法的方法体就代表了线程需要完成的任务。
  2. 创建Thread子类的实例。
  3. 调用线程对象的start（）方法来启动该线程。

- 实现Runnable接口创建线程类
  1. 定义Runnable的实现类，重写run（）方法。
  2. 创建Runnable实现类的实例，并以此作为Thread的target来创建对象，该对象才是真正的线程对象。

- 使用Callable和Future创建线程 
  1. 创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。
  2.  使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。 
  3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。 
  4. 调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。 

- 优缺点对比：

  1. 采用实现Runnable、Callable接口的方式创建多线程的优缺点。 

     - 优势： 
       - 线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。 
       - 在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来**处理同一份资源（解耦的思想）**的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 

     - 劣势：
       - 编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。

  2. 采用继承Thread类的方法创建多线程的优缺点。

     - 优势：
       - 编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。

     - **劣势**：
       - 因为线程类已经继承了Thread类，所以不能再继承其他父类。

<h2>Lambda的原理</h2>

- Lambda表达式在Java 8中首先会生成一个私有的静态函数，这个私有的静态函数干的就是Lambda表达式里面的内容
- 那么如何实现调用静态的lambda$0函数呢，可以发现在有lambda表达式的地方，运行时会进入metafactory函数。这个函数中可以发现为Lambda表达式生成了一个内部类：实现上调用的是Lambda.lambda$0这个私有的静态方法

```java
/**相当于如下的代码*/
interface Print<T> {
    public void print(T x);
}
public class Lambda {   
    public static void PrintString(String s, Print<String> print) {
        print.print(s);
    }
    private static void lambda$0(String x) {
        System.out.println(x);
    }
    final class $Lambda$1 implements Print{
        @Override
        public void print(Object x) {
            lambda$0((String)x);
        }
    }
    public static void main(String[] args) {
        PrintString("test", new Lambda().new $Lambda$1());
    }
}
```

<h2>建立联合索引的方法</h2>

- 在联合索引中将**区分度**（优化器对区分度低的索引，可能就直接不用上索引了。会失误，因为涉及了随机采样）最高的列放在索引最前面。例如：在一个公司里以age 和gender为索引，显然age要放在前面，因为性别就两种选择男或女，选择性不如age。
- 从B+树的角度来说，直接就是二叉树，根本没有发挥B+树的排序的优势。
- 联合索引还是一棵B+树，***每个节点包含了所有的索引键***。**先根据第一列排序，在第一列一样的情况下，第二列再排序假如是多列，就按多列数据排序**。例如有（1,1） （2,2） （2,1） （1,2），那在索引中的叶子节点的数据顺序就是（1,1）（1,2）（2,1）（2,2）

<h2>Spring和SpringBoot的区别</h2>

![img](https://img-blog.csdn.net/2018053117022189?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjY2Xw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	1.创建独立的Spring应用程序。SpringBoot可以jar包的形式进行独立的运行，使用：java -jar xx.jar就可以成功运行项目，或者在项目的主程序中运行main函数。 

​	2.springboot项目不需要单独下载Tomcat等传统服务器，内嵌容器，使得我们可以执行运行项目的主程序main函数，并让项目的快速运行，另外，也降低对运行环境的基本要求，环境变量中有JDK即可。 

​	3.Spring Boot提供了一系列的starter pom用来简化我们的Maven依赖，通过这些starter项目就能以Java Application的形式运行Spring Boot项目，而无需其他服务器配置。 

​	4.Spring Boot提供Spring框架的最大自动化配置，大量使用自动配置，使得开发者对Spring的配置尽量减少。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。

<h2>disctinct和group by的区别

- **distinct简单来说就是用来去重的，而group by的设计目的则是用来聚合统计的**，两者在能够实现的功能上有些相同之处，但应该仔细区分，因为用错场景的话，效率相差可以倍计。
- **单纯的去重操作使用distinct，速度是快于group by的**。

<h2>mysql实现分布式锁</h2>

- **应该是类似于redis？**Mysql实现分布式悲观锁:直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。

<h2>CMS中的Concurrent Mode Failure的解决方法</h2>

- 空间碎片太多
  方案：开启空间碎片整理，并将空间碎片整理周期设置在合理范围
  -XX:+UseCMSCompactAtFullCollection （空间碎片整理）

- 垃圾产生速度超过清理速度
  晋升阈值过小；所以很快就到了老年代当中
  Survivor空间过小，导致溢出；
  Eden区过小，导致晋升速率提高；
  存在大对象；

<h2>left join,right join,inner join,full join之间的区别</h2>

- inner join（内连接），在两张表进行连接查询时，只保留两张表中完全匹配的结果集。

- left join,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。

- right join,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

- full join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。

<h2>用户反映你开发的网站访问很慢可能会是什么原因</h2>

（1）某个用户反馈网站访问变慢，怎么去定位问题。首先你自己也打开下网站，看是否会出现用户反映的问题，如果你这边访问没问题，那就可能是用户那边的问题了，这块就是要先确定是用户那一方的问题还是自身比如说服务器或者网站的问题。

简单理解成是server端出现的问题，而不是client端出现了问题

- 可能的原因一：服务器出口带宽不够用。这是一个很常见的瓶颈。
- 可能原因二：服务器负载过大忙不过来，比如说CPU和内存消耗完了，这个容易理解，不展开。
- 可能原因三：1. 网站的开发代码没写好，例如mysql语句没有进行优化，导致数据库的读写相当耗费时间；2. 数据库的瓶颈，也是很常见的一个瓶颈，这点跟上面第三个原因可以一起来说。当我们的数据库变得愈发庞大

<h2>HashMap的内存泄漏问题</h2>

一个对象的hashCode() 方法的值，一般来说都是和对象的内容相关的。那么，如果Key对象的成员取值变化了，它的hashCode() 基本上也会变化。

设想一下，一个KV对被put 到HashMap中的时候，hashCode 是A，然后这个时候修改了Key的内容，使得它的hashCode变化了；那么接下来再用 get 方法获取这个 Value 时，会用这个Key重新计算hashCode，然后去内部查找，由于hashCode已经变化了，所以这时是找不到的。

**总结一下**，按照下面的场景使用HashMap的话，会出现**内存泄漏**的问题：

1. 作为Key的类有自定义的 hashCode() 方法，并且该方法的返回值受Key的类成员影响；

2. 在一个Key被put 到HashMap中以后，它的内部成员值发生了变化，并且导致了 hashCode 的结果变化；

### 3. 如何解决该问题？

从以上的分析可以知道，该问题的本质原因，在一个Key被放进HashMap 和从 HashMap 取出时，两次计算它的 hashCode 不一致导致的。所以要避免这个问题，就需要保证一个 Key 在 put 和 get 时，它的hashCode 保持不变。

具体实现为：

1. 保证作为HashMap 的Key 的对象是不可变的。也就是使用只读多对象来当作Key；

2. 如果要使用一个类当作HashMap的key，同时也要修改它的内容。那么可以重写hashCode，保证hashCode 的生成只和某些不可变的成员相关。
