package dp;

/**
 * @author luzhi
 * @date 2021/3/2
 */
/*
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
    从下标为 0 跳到下标为 1 的位置，跳1步，然后跳3步到达数组的最后一个位置。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/jump-game-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

DP+双指针+贪心

我们定义 f(i) 为到达第 i 个位置所需要的最少步数，那么答案是 f(n - 1)。
PS. 这里的状态定义我是猜的，这其实是个技巧。通常我们做 DP 题，都是先猜一个定义，
然后看看这个定义是否能分析出状态转移方程帮助我们不重不漏的枚举所有的方案。一般我是直接根据答案来猜定义，这里是求最小步数，所以我猜一个 f(i) 代表至少步数。

那么 f(n - 1) 该怎么求呢？
我们知道最后一个点前面可能会有很多个点能够一步到达最后一个点：
也就是有 f[n - 1] = min(f[n - k],...,f[n - 3],f[n - 2]) + 1。

然后我们再来考虑集合 f[n - k],...,f[n - 3],f[n - 2] 有何特性。
不然发现其实必然有 f[n - k] <= ...<= f[n - 3] <= f[n - 2]。

推而广之，不止是经过一步能够到达最后一个点的集合，其实任意连续的区间都有这个性质。
举个🌰，比如我经过至少 5 步到达第 i 个点，那么必然不可能出现使用步数少于 5 步就能达到第 i + 1 个点的情况。到达第 i + 1 个点的至少步数必然是 5 步或者 6 步 ~

搞清楚性质之后，再回头看我们的状态定义：f(i) 为到达第 i 个位置所需要的最少步数。
因此当我们要求某一个 f[i] 的时候，我们需要找到最早能够经过一步到达 i 点的 j 点。

即有状态转移方程：f(i) = f(j) + 1。
也就是我们每次都贪心的取离 i 点最远的点 j 来更新 f(i)。
而这个找 j 的过程可以使用双指针来找。
 */
public class Test_45 {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        int j = 0;
        for (int i = 1; i < n; i++) {
            // 找到最早能达到i点的j点
            while (j < i && (j + nums[j] < i)) {
                ++j;
            }
            dp[i] = dp[j] + 1;
        }
        return dp[n - 1];
    }
}
